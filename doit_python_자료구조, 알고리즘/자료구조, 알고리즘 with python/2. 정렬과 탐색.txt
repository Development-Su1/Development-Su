2. 정렬과 탐색 (Sorting & Searching)

!!! 정렬(sort)
- 복수의 원소로 주어진 데이터를 정해진 기준에 따라 새롭게 늘어놓는 작업
ex) # 요소의 길이를 기준으로 설정
    list.sort(key=lambda x: len(x))

ex) 'name' 레코드를 기준으로 정렬
    list.sort(key=lambda x: x['name'])

!! 정렬 관련 함수 & 메서드
- sorted(list, reverse=boolean) : 정렬된 리스트를 반환 (기존 list 는 변화 없음)
- list.sort( reverse=boolean ) : 리스트를 정렬함
# reverse = True >> 내림차순으로 정렬하고 싶을 때 사용

- 문자열로 이루어진 리스트의 경우에는 정렬 순서는 사전 순서 즉, 알파벳 순서를 따름 (문자열 길이가 긴 것이 더 큰 것이 아님)
- 문자열 길이로 정렬하려면 정렬에 이용하는 키(key)를 지정하여 정렬

# key값에 lambda 식을 설정하여 원하는 정렬 조건을 지정
- 람다 사용법 >> lambda 인자 : 표현식
ex) L = ['abcd', 'xyz', 'spam']
    sorted(L, key=lambda x: len(x))
    ['xyz', 'abcd', 'spam']

>>> L = ['spam', 'xyz', 'abcd']
    sorted(L, key=lambda x: len(x))
    ['xyz', 'spam', 'abcd']

ex) L=[{'name':'john', 'score':83},{'name':'Paul', 'score':92}]
    L.sort(key=lambda x: x['score'], reverse=True)
    [{'name': 'Paul', 'score': 92}, {'name': 'john', 'score': 83}]


!!! 탐색(search)

!! 선형 탐색(Linear Search) & 순차적 탐색 (O(n))
- 리스트의 요소들을 처음부터 순차적으로 탐색하여 원하는 값을 찾는 방법이다.
- 원하는 값이 발견되지 않을 경우 배열에 있는 모든 원소를 전부 검사한다.
ex) def linear_search(L, x):
	i = 0
    	while i < len(L) and L[i] != x:
        
        i += 1
        if i < len(L):
        	return i
        else:
        	return -1

 S = [3, 8, 2, 7, 6, 10, 9]
 linear_search(S, 6)
 4

 linear_search(S, 1)
 -1

linear_search(S, 11)
Traceback (most recent call last):
ValueError: 11 is not in list

!! 이진 탐색(binary Search)
- 탐색하려는 리스트가 이미 정렬되어 있는 경우에만 적용 가능
- 크기 순으로 정렬되어 있다는 성질을 이용
- 한 번 비교가 일어날 때마다 리스트가 반씩 줄임(divide & conquer) → O(log n)
ex) lower = 0
upper = len(L) - 1
idx = -1

while lower <= upper:
	middle = (lower + uppser) // 2
    if L[middle] == target:
    	...
    elif L[middle] < target:
    	lower = ...
    else:
    	upper = ...

!! 차이
배열의 크기가 커질수록 동작시간이 기하급수적으로 커지는 선형 탐색 & 순차적 탐색에 비해 이진 탐색 방식은 배열의 크기가 동작시간에 큰 영향을 주지 않는다.
하지만, 이미 정렬된 배열이 우선적으로 필요하기 때문에 일회성으로 사용되는 데이터에서 값을 찾을 때 보다 주기적으로 데이터 탐색이 필요한 데이터 목록에서 사용하면 좋다.
왜냐하면 일회성으로 탐색 후 사용하지 않는 데이터에서 굳이 정렬을 추가로 해줄 필요는 없기 때문이다.



